# データ処理仕様書

**作成日**: 2025-11-18 15:30
**対象**: RS2024サンキー図システム - データ処理パイプライン

## 概要

本システムのデータ処理パイプラインは、RSシステムの生CSVデータから可視化用JSONファイルまでの一連の処理を定義する。

---

## 1. データ処理フロー

```
[RSシステム]
    ↓ ダウンロード
[Shift_JIS CSV (15ファイル)]
    ↓ 正規化処理
[UTF-8 正規化CSV]
    ↓ パース・集計
[Sankey JSON (8ファイル)]
    ↓ 配信
[Next.js Public Assets]
```

---

## 2. ステージ1: CSVダウンロード・正規化

### 2.1 スクリプト

- **ファイル**: `scripts/download_and_normalize.py`
- **実行コマンド**: `npm run setup-data`
- **前提条件**: Python 3.x

### 2.2 処理内容

#### Phase 1: ダウンロード

- **データソース**: https://rssystem.go.jp/download-csv/2024
- **対象ファイル数**: 15個
- **エンコーディング**: Shift_JIS
- **保存先**: `data/rs_system/year_2024/temp/`

**ダウンロード対象ファイル**:
```
1-1_2024_基本情報_組織情報.csv
1-2_2024_基本情報_政策体系情報.csv
1-3_2024_基本情報_事業概要.csv
2-1_2024_予算・執行_サマリ.csv
2-2_2024_予算・執行_予算の状況.csv
2-3_2024_予算・執行_執行額の内訳.csv
3-1_2024_成果目標・成果実績_サマリ.csv
3-2_2024_成果目標・成果実績_成果目標及び成果実績.csv
3-3_2024_成果目標・成果実績_活動指標及び活動実績.csv
4-1_2024_点検結果_点検結果.csv
5-1_2024_支出先_支出情報.csv
5-2_2024_支出先_支出先上位10者リスト.csv
6-1_2024_契約方式_随意契約の理由.csv
7-1_2024_外部委託_外部委託費内訳.csv
8-1_2024_関連事業_関連事業.csv
```

#### Phase 2: テキスト正規化

各CSVセルに対して以下の処理を順次適用：

1. **丸数字の変換**: ①②③... → 1,2,3...
   ```python
   circled = '①②③④⑤⑥⑦⑧⑨⑩⑪⑫⑬⑭⑮⑯⑰⑱⑲⑳'
   for i, char in enumerate(circled, 1):
       text = text.replace(char, str(i))
   ```

2. **Unicode NFKC正規化**: 全角英数字→半角、異体字統一
   ```python
   text = unicodedata.normalize('NFKC', text)
   ```

3. **和暦→西暦変換**:
   ```python
   令和5年 → 2023年
   平成30年 → 2018年
   昭和64年 → 1989年
   ```

4. **全角括弧→半角括弧変換**:
   ```python
   （） → ()
   ```

5. **ハイフン→長音の修正** (カタカナ後のハイフン):
   ```python
   カタカナ後の'-' → 'ー'
   例: デ-タ → デ ータ
   ```

6. **ハイフン・ダッシュの統一**:
   ```python
   −, －, ‐, –, —, ― → - (ASCIIハイフン)
   ```

7. **カタカナ長音記号の誤用修正**:
   ```python
   連続長音を1つに: コーーヒー → コーヒー
   ```

8. **連続空白の削除**:
   ```python
   re.sub(r'\s+', ' ', text).strip()
   ```

#### Phase 3: 出力

- **エンコーディング**: UTF-8 (BOMなし)
- **出力先**: `data/rs_system/year_2024/`
- **クリーンアップ**: 一時ディレクトリ `temp/` を削除

### 2.3 正規化の意義

| 課題 | 正規化による解決 |
|------|----------------|
| 文字コード混在 | UTF-8統一でプラットフォーム依存性排除 |
| 表記ゆれ | NFKC正規化で全角/半角統一 |
| 和暦の扱いづらさ | 西暦変換で年度計算を簡素化 |
| ハイフンの混乱 | ASCII統一でマッチング精度向上 |
| 不要な空白 | データクリーニングで処理効率化 |

---

## 3. ステージ2: CSV読み込み

### 3.1 スクリプト

- **ファイル**: `scripts/csv-reader.ts`
- **関数**: `readShiftJISCSV(filePath: string): CSVRow[]`

### 3.2 エンコーディング自動判定

```typescript
// UTF-8を優先的に試行（正規化後CSV対応）
try {
  content = buffer.toString('utf-8');
  if (content.includes('�')) {
    throw new Error('UTF-8 decoding failed');
  }
} catch {
  // Shift_JISにフォールバック（元のCSV対応）
  content = iconv.decode(buffer, 'Shift_JIS');
}
```

**判定ロジック**:
1. UTF-8として読み込みを試行
2. 文字化け（�）が含まれる場合、Shift_JISで再試行
3. どちらでも読み込み可能な設計

### 3.3 CSVパース仕様

- **フィールド区切り**: カンマ (`,`)
- **クォート対応**: ダブルクォート (`"`) 囲み
- **エスケープ**: `""` → `"`
- **改行コード**: `\r\n` または `\n`
- **空行処理**: スキップ

### 3.4 金額パース

```typescript
function parseAmount(amountStr: string): number {
  const cleaned = amountStr.replace(/,/g, '').trim();
  const value = Number(cleaned);
  return isNaN(value) ? 0 : value;
}
```

**処理内容**:
- カンマ除去
- トリム
- 数値変換（失敗時は0）

---

## 4. ステージ3: Sankey図JSON生成

### 4.1 予算ドリルダウン

#### スクリプト
- **ファイル**: `scripts/generate-budget-sankey.ts`
- **出力**: `public/data/budget-drilldown-top{5,10,20,50}.json`

#### データフロー
```
総予算 → 省庁(TopN) → 部局 → 課 → 係 → プロジェクト(管理番号)
```

#### 処理ステップ

1. **CSVロード**:
   - `1-1_2024_基本情報_組織情報.csv`
   - `2-1_2024_予算・執行_サマリ.csv`

2. **2024年度フィルタ**:
   ```typescript
   const org2024 = orgRows.filter(row => row.予算年度 === '2024');
   const budget2024 = budgetRows.filter(row => row.予算年度 === '2024');
   ```

3. **データ結合**:
   ```typescript
   const orgMap = new Map<string, OrganizationInfo>();
   for (const row of org2024) {
     orgMap.set(row.管理番号, row);
   }
   ```

4. **省庁別集計**:
   ```typescript
   const ministryBudgets = new Map<string, number>();
   for (const project of projects) {
     const current = ministryBudgets.get(project.省庁) || 0;
     ministryBudgets.set(project.省庁, current + project.予算額);
   }
   ```

5. **TopNソート**:
   ```typescript
   const sortedMinistries = Array.from(ministryBudgets.entries())
     .sort((a, b) => b[1] - a[1]);
   const topMinistries = sortedMinistries.slice(0, topN);
   ```

6. **その他集約**:
   ```typescript
   const othersBudget = sortedMinistries.slice(topN)
     .reduce((sum, [, budget]) => sum + budget, 0);
   ```

7. **ノード・リンク構築**:
   - ノードID命名規則: `{省庁}::{部局}::{課}::{係}`
   - リンクの source/target 整合性検証

#### 出力例
```json
{
  "nodes": [
    { "id": "総予算" },
    { "id": "財務省" },
    { "id": "その他省庁" }
  ],
  "links": [
    { "source": "総予算", "target": "財務省", "value": 5000000 },
    { "source": "総予算", "target": "その他省庁", "value": 2000000 }
  ]
}
```

### 4.2 支出ボトムアップ

#### スクリプト
- **ファイル**: `scripts/generate-spending-sankey.ts`
- **出力**: `public/data/spending-bottomup-top{5,10,20,50}.json`

#### データフロー
```
支出先 → プロジェクト(管理番号) → 係 → 課 → 部局 → 省庁 → 総支出
```

#### 処理ステップ

1. **CSVロード**:
   - `1-1_2024_基本情報_組織情報.csv`
   - `5-1_2024_支出先_支出情報.csv`

2. **支出先別集計**:
   ```typescript
   const recipientMap = new Map<string, RecipientData>();
   for (const spending of spendingRows) {
     const recipientName = spending.支出先名称.trim();
     if (!recipientMap.has(recipientName)) {
       recipientMap.set(recipientName, {
         支出先名称: recipientName,
         総支出額: 0,
         プロジェクト: [],
       });
     }
     const recipient = recipientMap.get(recipientName)!;
     recipient.総支出額 += amount;
     recipient.プロジェクト.push({...});
   }
   ```

3. **TopN選択**:
   ```typescript
   const sortedRecipients = recipients
     .sort((a, b) => b.総支出額 - a.総支出額);
   const topRecipients = sortedRecipients.slice(0, topN);
   ```

4. **逆フロー構築**: 支出先 → 総支出 の方向でリンク作成

---

## 5. データ整合性検証

### 5.1 バリデーションルール

```typescript
function validateSankeyData(data: SankeyData): void {
  const nodeIds = new Set(data.nodes.map(n => n.id));

  for (const link of data.links) {
    // ノードID存在チェック
    if (!nodeIds.has(link.source)) {
      throw new Error(`Invalid source: ${link.source}`);
    }
    if (!nodeIds.has(link.target)) {
      throw new Error(`Invalid target: ${link.target}`);
    }

    // 値チェック
    if (link.value <= 0) {
      throw new Error(`Invalid value: ${link.value}`);
    }

    // 自己ループチェック
    if (link.source === link.target) {
      throw new Error('Self-loop detected');
    }
  }
}
```

### 5.2 データ品質保証

| 項目 | 検証内容 |
|------|---------|
| ノードID一意性 | 重複チェック |
| リンク参照整合性 | source/targetがnodes配列に存在 |
| 金額正当性 | value > 0 |
| 自己ループ禁止 | source ≠ target |
| 孤立ノード回避 | すべてのノードが少なくとも1本のリンクを持つ |

---

## 6. パフォーマンス最適化

### 6.1 事前生成戦略

- **タイミング**: ビルド時（`npm run build`）
- **利点**:
  - ブラウザでの処理不要
  - 初期表示高速化
  - サーバー負荷軽減

### 6.2 ファイルサイズ管理

| TopN | 想定ノード数 | 想定ファイルサイズ |
|------|------------|------------------|
| 5 | ~50 | ~10KB |
| 10 | ~100 | ~20KB |
| 20 | ~200 | ~40KB |
| 50 | ~500 | ~100KB |

### 6.3 CDN配信

- **配置**: `public/data/` → Vercel Edge Network
- **キャッシュ**: 静的アセットとして長期キャッシュ
- **配信**: グローバルCDNで低レイテンシ

---

## 7. エラーハンドリング

### 7.1 CSV読み込みエラー

```typescript
if (!fs.existsSync(csvPath)) {
  console.error('❌ CSVファイルが見つかりません');
  console.error('npm run setup-data を実行してください');
  process.exit(1);
}
```

### 7.2 データ不整合エラー

```typescript
if (!orgMap.has(budgetRow.管理番号)) {
  console.warn(`管理番号 ${budgetRow.管理番号} の組織情報が見つかりません`);
  continue; // スキップ
}
```

### 7.3 正規化エラー

```python
try:
    normalize_csv_file(input_path, output_path)
except Exception as e:
    print(f'❌ エラー: {input_path.name} - {e}')
    # 処理を継続（他のファイルに影響させない）
```

---

## 8. テスト戦略

### 8.1 単体テスト

- CSVパース: 各種エンコーディング、エスケープ、改行コード
- 正規化: 各変換ルールの個別検証
- 金額パース: カンマ、空白、不正値

### 8.2 統合テスト

1. ダウンロード → 正規化 → パース の一連フロー
2. 生成されたJSONの妥当性検証
3. 実データでのエンドツーエンド処理

### 8.3 手動検証

```bash
# セットアップ実行
npm run setup-data

# ファイル確認
ls data/rs_system/year_2024/*.csv
ls public/data/*.json

# JSON検証
cat public/data/budget-drilldown-top10.json | jq .
```

---

## 変更履歴

| 日付 | 変更内容 | 担当 |
|------|---------|------|
| 2025-11-18 | 初版作成 | Claude |
