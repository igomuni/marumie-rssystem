# 支出ビュー仕様

## 1. 概要

支出ビュー（Spending View）は、特定の支出先を起点として、どの府省庁・事業から資金が流れているかを可視化するビューです。

---

## 2. データフロー

### 2.1 基本フロー

```
支出先を選択
  ↓
1. 全支出先から、一致する支出先名を抽出する
   - 総支出も集計
  ↓
2. 事業名毎に支出額をリンク
  ↓
3. 事業(支出)にリンクする事業(予算)を抽出
   - 事業の予算額を取得
  ↓
4. 事業(予算)にリンクする府省庁を抽出
   - 府省庁毎に予算額を集計
  ↓
5. TopNの設定に基づきノードをまとめる
```

### 2.2 Sankeyダイアグラムの構造

```
Column 0          Column 1          Column 2          Column 3          Column 4
府省庁予算 ────→ 事業予算 ────→ 事業支出 ────→ （なし） ────→ 支出先
```

---

## 3. データ選択ロジック

### 3.1 入力パラメータ

| パラメータ | 意味 | 例 |
|-----------|------|-----|
| `targetRecipientName` | 選択された支出先名 | `総務省` |
| `ministryLimit` | TopN府省庁の数 | `1` |
| `projectLimit` | TopN事業の数 | `10` |
| `projectOffset` | 事業ページネーションのオフセット | `0` |

### 3.2 選択ステップ

#### Step 1: 支出先に一致する支出レコードを抽出
```typescript
// 支出先名が一致するレコードを全て取得
const recipientSpendings = data.spendings.filter(
  s => s.spendingName === targetRecipientName
);

// 総支出額を集計
const totalSpending = recipientSpendings.reduce(
  (sum, s) => sum + s.totalSpendingAmount, 0
);
```

#### Step 2: 事業名毎に支出額をリンク
```typescript
// 各事業IDとその支出額のマップを作成
const amountByProject = new Map<number, number>();

for (const spending of recipientSpendings) {
  for (const project of spending.projects) {
    const current = amountByProject.get(project.projectId) || 0;
    amountByProject.set(project.projectId, current + project.amount);
  }
}
```

**結果**: `amountByProject` = 各事業が対象支出先に支払った金額

#### Step 3: 事業(予算)を抽出
```typescript
// 関連する事業の詳細を取得
const contributingProjects = data.budgets.filter(
  b => amountByProject.has(b.projectId)
);

// 支出額でソート
const sortedProjects = contributingProjects.sort((a, b) =>
  (amountByProject.get(b.projectId) || 0) -
  (amountByProject.get(a.projectId) || 0)
);
```

**結果**: 支出額が多い順に並んだ事業リスト

#### Step 4: 府省庁毎に支出額を集計
```typescript
// 府省庁別の支出額マップを作成
const allMinistrySpending = new Map<string, number>();

for (const project of sortedProjects) {
  const amount = amountByProject.get(project.projectId) || 0;
  const current = allMinistrySpending.get(project.ministry) || 0;
  allMinistrySpending.set(project.ministry, current + amount);
}
```

**結果**: `allMinistrySpending` = 各府省庁が対象支出先に支払った総額

#### Step 5: TopN選択とノード集約

##### 5-1. TopN府省庁を選択
```typescript
const sortedMinistries = Array.from(allMinistrySpending.entries())
  .sort((a, b) => b[1] - a[1]);

const topMinistryNames = new Set(
  sortedMinistries.slice(0, ministryLimit).map(([name]) => name)
);
```

**例**: `ministryLimit=1` の場合、支払額が最も多い府省庁を1つ選択

##### 5-2. TopN事業を選択
```typescript
// projectOffset～projectOffset+projectLimitの範囲で事業を選択
const candidateProjects = sortedProjects.slice(
  projectOffset,
  projectOffset + projectLimit
);

// TopN府省庁に属する事業のみをフィルタ
topProjects = candidateProjects.filter(
  p => topMinistryNames.has(p.ministry)
);
```

**重要**: TopN事業は **TopN府省庁に属する事業のみ** に限定される

##### 5-3. TopN以外の事業を集約（TopN府省庁内）
```typescript
// TopN府省庁に属するが、TopNに選ばれなかった事業の支出額を集計
let otherProjectsAmount = 0;

// ページネーション前のプロジェクト
for (let i = 0; i < projectOffset; i++) {
  const project = sortedProjects[i];
  if (topMinistryNames.has(project.ministry)) {
    otherProjectsAmount += amountByProject.get(project.projectId) || 0;
  }
}

// ページネーション後のプロジェクト
for (let i = projectOffset + projectLimit; i < sortedProjects.length; i++) {
  const project = sortedProjects[i];
  if (topMinistryNames.has(project.ministry)) {
    otherProjectsAmount += amountByProject.get(project.projectId) || 0;
  }
}

// candidateProjectsの中でTopN府省庁に属さない事業
for (const project of candidateProjects) {
  if (!topMinistryNames.has(project.ministry)) {
    otherProjectsAmount += amountByProject.get(project.projectId) || 0;
  }
}
```

**結果**: `otherProjectsSpendingInSpendingView` = TopN府省庁からの「事業(TopN以外)」

##### 5-4. TopN以外の府省庁を集約
```typescript
// TopN以外の府省庁からの全支出額を集計
let nonTopMinistrySpending = 0;

for (let i = ministryLimit; i < sortedMinistries.length; i++) {
  nonTopMinistrySpending += sortedMinistries[i][1];
}
```

**結果**: `otherMinistriesSpendingInSpendingView` = TopN以外の府省庁からの全支出

---

## 4. ノード生成ロジック

### 4.1 通常ノード

#### 府省庁ノード（TopN府省庁）
```typescript
for (const ministry of topMinistries) {
  nodes.push({
    id: `ministry-budget-${ministry.id}`,
    name: ministry.name,
    type: 'ministry-budget',
    value: ministry.totalBudget,
  });
}
```

#### 事業ノード（TopN事業）
```typescript
for (const project of topProjects) {
  // Column 1: 事業予算
  nodes.push({
    id: `project-budget-${project.projectId}`,
    name: project.projectName,
    type: 'project-budget',
    value: project.totalBudget,
  });

  // Column 2: 事業支出
  nodes.push({
    id: `project-spending-${project.projectId}`,
    name: project.projectName,
    type: 'project-spending',
    value: amountByProject.get(project.projectId) || 0,
  });
}
```

#### 支出先ノード
```typescript
nodes.push({
  id: `recipient-${recipientSpendings[0].spendingId}`,
  name: targetRecipientName,
  type: 'recipient',
  value: totalSpending,
});
```

### 4.2 集約ノード

#### 集約ノード A: TopN府省庁からの「事業(TopN以外)」

**目的**: TopN府省庁に属するが、事業TopNに選ばれなかった事業を集約

```typescript
if (otherProjectsSpending > 0) {
  // Column 1: 事業予算(TopN以外)
  nodes.push({
    id: 'project-budget-other-spending-view',
    name: `事業(Top${projectLimit}以外)`,
    type: 'project-budget',
    value: otherProjectsSpending,
  });

  // Column 2: 事業支出(TopN以外)
  nodes.push({
    id: 'project-spending-other-spending-view',
    name: `事業(Top${projectLimit}以外)`,
    type: 'project-spending',
    value: otherProjectsSpending,
  });
}
```

**リンク**:
```
TopN府省庁 → project-budget-other-spending-view
           → project-spending-other-spending-view
           → 支出先
```

#### 集約ノード B: TopN以外の府省庁からの全事業

**目的**: TopN府省庁に選ばれなかった府省庁の全事業を集約

```typescript
if (otherMinistriesSpending > 0) {
  // Column 0: 府省庁予算(TopN以外)
  nodes.push({
    id: 'ministry-budget-other-spending-view',
    name: `府省庁(Top${ministryLimit}以外)`,
    type: 'ministry-budget',
    value: otherMinistriesSpending,
  });

  // Column 1: 事業予算(TopN以外・府省庁)
  nodes.push({
    id: 'project-budget-other-ministry-spending-view',
    name: `事業(Top${ministryLimit}以外府省庁)`,
    type: 'project-budget',
    value: otherMinistriesSpending,
  });

  // Column 2: 事業支出(TopN以外・府省庁)
  nodes.push({
    id: 'project-spending-other-ministry-spending-view',
    name: `事業(Top${ministryLimit}以外府省庁)`,
    type: 'project-spending',
    value: otherMinistriesSpending,
  });
}
```

**リンク**:
```
ministry-budget-other-spending-view
  → project-budget-other-ministry-spending-view
  → project-spending-other-ministry-spending-view
  → 支出先
```

---

## 5. 現在の問題点

### 5.1 問題の具体例

**条件**:
- 支出先 = `総務省`
- `ministryLimit` = 1（TopN府省庁: 防衛省のみ）
- `projectLimit` = 10（TopN事業: 10事業）

**期待される表示**:
```
府省庁(Top1以外) → 事業(...) → 事業(...) → 総務省  // TopN以外府省庁
防衛省 → プロジェクトA～J → プロジェクトA～J → 総務省  // TopN事業×10
防衛省 → 事業(Top10以外) → 事業(Top10以外) → 総務省  // TopN府省庁のTopN以外事業
```

**実際の表示**:
```
府省庁(Top1以外) → 事業(Top1以外府省庁) → 事業(Top1以外府省庁) → 総務省  ✅
防衛省 → プロジェクトA～J → プロジェクトA～J → 総務省  ✅
防衛省 → 事業(Top10以外) → 事業(Top10以外) → 総務省  ❌ まだ存在する
```

### 5.2 原因

2種類の「事業(TopN以外)」ノードが生成されている:

1. **`事業(Top10以外)`**
   - 意味: TopN府省庁（防衛省）のTopN以外の事業
   - ソース: `otherProjectsSpendingInSpendingView`

2. **`事業(Top1以外府省庁)`**
   - 意味: TopN以外の府省庁（厚労省、国交省など）の全事業
   - ソース: `otherMinistriesSpendingInSpendingView`

**問題**: ノード名が異なるため、両方とも表示されてしまう

### 5.3 想定される原因

**仮説1**: `otherProjectsSpendingInSpendingView` の計算が間違っている
- TopN府省庁（防衛省）のTopN事業（10事業）以外の事業が正しく除外されていない

**仮説2**: リンク生成のロジックが間違っている
- TopN府省庁から `project-budget-other-spending-view` へのリンクが生成されていない

**仮説3**: TopN事業のフィルタリングが間違っている
- `topProjects` に本来含まれるべき事業が含まれていない

---

## 6. 調査すべき箇所

### 6.1 データ選択ロジック（app/lib/sankey-generator.ts: L270-314）

#### 確認項目:
1. `candidateTopProjects` に含まれる事業数
2. `topProjects` に含まれる事業数（TopN府省庁フィルタ後）
3. `otherProjectsSpendingInSpendingView` の計算が正しいか

#### デバッグ用ログ:
```typescript
console.log('candidateTopProjects:', candidateTopProjects.length);
console.log('topProjects (after ministry filter):', topProjects.length);
console.log('otherProjectsAmount:', otherProjectsAmount);
```

### 6.2 ノード生成ロジック（app/lib/sankey-generator.ts: L794-862）

#### 確認項目:
1. `otherProjectsSpending` の値
2. `project-budget-other-spending-view` ノードが生成される条件
3. リンクが正しく生成されているか

#### デバッグ用ログ:
```typescript
console.log('otherProjectsSpending:', otherProjectsSpending);
if (otherProjectsSpending > 0) {
  console.log('Generating project-budget-other-spending-view node');
}
```

### 6.3 リンク生成ロジック（app/lib/sankey-generator.ts: L835-861）

#### 確認項目:
1. `otherProjectsSpendingByMinistryInSpendingView` の内容
2. TopN府省庁から `project-budget-other-spending-view` へのリンクが生成されているか

---

## 7. 修正方針（案）

### Option 1: TopN府省庁が1つの場合、集約ノードAを生成しない

**理由**: TopN府省庁が1つの場合、そのTopN事業以外は自動的にTopN以外府省庁に含まれるべき

```typescript
// TopN府省庁が1つの場合は集約ノードAを生成しない
if (otherProjectsSpending > 0 && topMinistries.length > 1) {
  // 集約ノードA生成
}
```

### Option 2: 集約ノードAの計算ロジックを修正

**現状の問題**: TopN府省庁のTopN以外事業が正しく計算されていない可能性

**修正案**: `selectData` 内で `otherProjectsSpendingInSpendingView` を計算する際、TopN府省庁に属する事業のみをカウントする

### Option 3: ノード名を明確化

**案**:
- 集約ノードA: `事業(Top10以外・TopN府省庁)` → `事業(Top10以外・防衛省)`
- 集約ノードB: `事業(Top1以外府省庁)` → `事業(全事業・TopN以外府省庁)`

---

## 8. 次のステップ

1. デバッグログを追加して、データ選択ロジックを確認
2. `otherProjectsSpendingInSpendingView` の計算が正しいか検証
3. 修正方針を決定（Option 1～3）
4. 実装とテスト
