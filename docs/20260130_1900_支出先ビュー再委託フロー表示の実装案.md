# 支出先ビュー再委託フロー表示の実装案

## 1. 目的

支出先ビューで、選択した支出先から再委託先への資金フローを表示する。

**Before（現在）**:
```
府省庁 → 事業(予算) → 事業(支出) → [支出先]
```

**After（目標）**:
```
府省庁 → 事業(予算) → 事業(支出) → [支出先] → 再委託先
```

---

## 2. データ構造の変更

### 2.1 新しい型定義

**ファイル: `types/structured.ts`**

```typescript
// 支出ブロック間のフロー情報
export interface SpendingBlockFlow {
  sourceBlockNumber: string;        // 支出元ブロック番号（例: "A"）
  sourceBlockName: string;          // 支出元ブロック名（例: "株式会社博報堂"）
  targetBlockNumber: string;        // 支出先ブロック番号（例: "B"）
  targetBlockName: string;          // 支出先ブロック名（例: "東京電力EP等"）
  flowType: string;                 // 資金の流れの種類（例: "間接補助金"）
  isDirectFromGov: boolean;         // 担当組織からの直接支出か
}

// SpendingRecordに追加
export interface SpendingRecord {
  // 既存フィールド...

  // 再委託情報（5-2 CSVから）
  outflows?: SpendingBlockFlow[];   // この支出先から他への支出
  inflows?: SpendingBlockFlow[];    // この支出先への流入（親支出先から）
}
```

### 2.2 新しいCSV型定義

**ファイル: `types/rs-system.ts`**

```typescript
/**
 * 5-2_RS_2024_支出先_支出ブロックのつながり.csv
 * 支出ブロック間の資金フロー
 */
export interface SpendingBlockFlowInfo {
  シート種別: string;
  事業年度: string;
  予算事業ID: string;
  事業名: string;
  府省庁の建制順: string;
  政策所管府省庁: string;
  府省庁: string;
  '局・庁': string;
  部: string;
  課: string;
  室: string;
  班: string;
  係: string;
  支出元の支出先ブロック: string;
  支出元の支出先ブロック名: string;
  担当組織からの支出: string;           // "TRUE" or "FALSE"
  支出先の支出先ブロック: string;
  支出先の支出先ブロック名: string;
  資金の流れの補足情報: string;
  国自らが支出する間接経費: string;
  国自らが支出する間接経費の項目: string;
  国自らが支出する間接経費の金額: string;
}
```

---

## 3. データ生成スクリプトの変更

**ファイル: `scripts/generate-structured-json.ts`**

### 3.1 5-2 CSV読み込み処理の追加

```typescript
// 5-2 CSVを読み込む
const SPENDING_BLOCK_FLOW_CSV = path.join(DATA_DIR, '5-2_RS_2024_支出先_支出ブロックのつながり.csv');

async function loadSpendingBlockFlows(): Promise<SpendingBlockFlowInfo[]> {
  const rows = await readCSV<SpendingBlockFlowInfo>(SPENDING_BLOCK_FLOW_CSV);
  return rows;
}
```

### 3.2 支出ブロックフローのマップ構築

```typescript
interface BlockFlowMap {
  // key: "projectId_blockNumber" (例: "7259_A")
  // value: outflows（この支出先から他への流出）
  outflows: Map<string, SpendingBlockFlow[]>;

  // key: "projectId_blockNumber"
  // value: isDirectFromGov（政府から直接支出か）
  isDirectFromGov: Map<string, boolean>;
}

function buildBlockFlowMap(flowRows: SpendingBlockFlowInfo[]): BlockFlowMap {
  const outflows = new Map<string, SpendingBlockFlow[]>();
  const isDirectFromGov = new Map<string, boolean>();

  for (const row of flowRows) {
    const projectId = row.予算事業ID;
    const sourceBlock = row.支出元の支出先ブロック;
    const targetBlock = row.支出先の支出先ブロック;
    const isDirectStr = row.担当組織からの支出;

    if (!projectId || !targetBlock) continue;

    // 支出先ブロックが政府から直接支出かどうか
    if (isDirectStr === 'TRUE') {
      const key = `${projectId}_${targetBlock}`;
      isDirectFromGov.set(key, true);
    }

    // 支出元ブロックがある場合（再委託等）
    if (sourceBlock && isDirectStr === 'FALSE') {
      const sourceKey = `${projectId}_${sourceBlock}`;
      if (!outflows.has(sourceKey)) {
        outflows.set(sourceKey, []);
      }
      outflows.get(sourceKey)!.push({
        sourceBlockNumber: sourceBlock,
        sourceBlockName: row.支出元の支出先ブロック名,
        targetBlockNumber: targetBlock,
        targetBlockName: row.支出先の支出先ブロック名,
        flowType: row.資金の流れの補足情報 || '再委託',
        isDirectFromGov: false,
      });
    }
  }

  return { outflows, isDirectFromGov };
}
```

### 3.3 SpendingRecordへのフロー情報追加

```typescript
function buildSpendingRecords(
  spendingRows: SpendingInfo[],
  budgetRecords: BudgetRecord[],
  blockFlowMap: BlockFlowMap  // 追加
): {
  spendingRecords: SpendingRecord[];
  projectSpendingMap: Map<number, number[]>;
} {
  // ... 既存のロジック ...

  for (const row of spendingRows) {
    // ... 既存の処理 ...

    const blockKey = `${projectId}_${row.支出先ブロック番号}`;

    // 政府からの直接支出フラグを設定
    const isDirectFromGov = blockFlowMap.isDirectFromGov.get(blockKey) ?? true;

    // 間接支出（再委託先）は集計から除外するが、フロー情報は保持
    if (!isDirectFromGov) {
      // 間接支出は別途処理（または除外）
      continue;
    }

    // ... 既存の処理 ...
  }

  // SpendingRecordにoutflowsを追加
  for (const record of spendingRecords) {
    const outflows: SpendingBlockFlow[] = [];

    for (const project of record.projects) {
      const blockKey = `${project.projectId}_${project.blockNumber}`;
      const flows = blockFlowMap.outflows.get(blockKey) || [];
      outflows.push(...flows);
    }

    if (outflows.length > 0) {
      record.outflows = outflows;
    }
  }
}
```

---

## 4. サンキー生成ロジックの変更

**ファイル: `app/lib/sankey-generator.ts`**

### 4.1 新しいノードタイプの追加

```typescript
// types/preset.ts に追加
type: 'ministry-budget' | 'project-budget' | 'project-spending'
    | 'recipient' | 'subcontract-recipient' | 'expense-category' | 'other'
```

### 4.2 支出先ビューでの再委託フロー表示

```typescript
// generateSpendingViewSankey 関数内（支出先ビューの生成）

// 選択した支出先の再委託先を取得
const selectedRecipient = spendingRecords.find(s => s.spendingName === recipientName);
const outflows = selectedRecipient?.outflows || [];

// 再委託先ノードを生成（Column 4）
const subcontractNodes: SankeyNode[] = [];
const subcontractLinks: SankeyLink[] = [];

// 再委託先を集約（同名の支出先はまとめる）
const subcontractAggregation = new Map<string, {
  name: string;
  flowTypes: Set<string>;
  totalAmount: number;
}>();

for (const flow of outflows) {
  if (!subcontractAggregation.has(flow.targetBlockName)) {
    subcontractAggregation.set(flow.targetBlockName, {
      name: flow.targetBlockName,
      flowTypes: new Set(),
      totalAmount: 0,
    });
  }
  const agg = subcontractAggregation.get(flow.targetBlockName)!;
  agg.flowTypes.add(flow.flowType);
  // 金額は5-1 CSVから取得が必要（後述）
}

// 再委託先ノードを作成
for (const [name, data] of subcontractAggregation) {
  subcontractNodes.push({
    id: `subcontract-${name}`,
    name: name,
    type: 'subcontract-recipient',
    value: data.totalAmount,
    details: {
      flowTypes: Array.from(data.flowTypes).join(', '),
    }
  });

  // リンク: 支出先 → 再委託先
  subcontractLinks.push({
    source: recipientNodeId,
    target: `subcontract-${name}`,
    value: data.totalAmount,
    details: {
      flowType: Array.from(data.flowTypes).join(', '),
    }
  });
}

// ノードとリンクを追加
nodes.push(...subcontractNodes);
links.push(...subcontractLinks);
```

---

## 5. 金額の取得方法

### 課題

5-2 CSVには**金額情報がない**。再委託先の金額は5-1 CSVの「ブロックの合計支出額」から取得する必要がある。

### 解決策

```typescript
// 5-1 CSVから間接支出ブロックの金額を取得するマップを構築
function buildBlockAmountMap(spendingRows: SpendingInfo[]): Map<string, number> {
  const blockAmounts = new Map<string, number>();

  for (const row of spendingRows) {
    const key = `${row.予算事業ID}_${row.支出先ブロック番号}`;
    const amount = parseAmount(row.ブロックの合計支出額);

    if (!blockAmounts.has(key)) {
      blockAmounts.set(key, amount);
    }
  }

  return blockAmounts;
}

// 再委託先の金額を取得
for (const flow of outflows) {
  const blockKey = `${projectId}_${flow.targetBlockNumber}`;
  const amount = blockAmountMap.get(blockKey) || 0;
  // ...
}
```

---

## 6. UI表示の変更

### 6.1 色設定の追加

**ファイル: `app/sankey/page.tsx`**

```typescript
const getNodeColor = (node: SankeyNode) => {
  if (node.name.startsWith('その他')) return '#6b7280';  // Gray

  switch (node.type) {
    case 'ministry-budget':
    case 'project-budget':
      return '#10b981';  // Green (budget)
    case 'project-spending':
    case 'recipient':
      return '#ef4444';  // Red (spending)
    case 'subcontract-recipient':
      return '#f97316';  // Orange (subcontract)
    default:
      return '#6b7280';  // Gray
  }
};
```

### 6.2 ツールチップの拡張

```typescript
// 再委託先ノードのツールチップ
{node.type === 'subcontract-recipient' && (
  <div>
    <p>再委託先: {node.name}</p>
    <p>資金の流れ: {node.details?.flowTypes}</p>
    <p>金額: {formatBudget(node.value)}</p>
  </div>
)}
```

---

## 7. 修正ファイル一覧

| ファイル | 変更内容 | 工数 |
|----------|----------|------|
| [types/rs-system.ts](types/rs-system.ts) | SpendingBlockFlowInfo型追加 | 小 |
| [types/structured.ts](types/structured.ts) | SpendingBlockFlow型、SpendingRecord拡張 | 小 |
| [types/preset.ts](types/preset.ts) | subcontract-recipientノードタイプ追加 | 小 |
| [scripts/generate-structured-json.ts](scripts/generate-structured-json.ts) | 5-2 CSV読み込み、フローマップ構築 | **大** |
| [app/lib/sankey-generator.ts](app/lib/sankey-generator.ts) | 支出先ビューに再委託フロー追加 | **大** |
| [app/sankey/page.tsx](app/sankey/page.tsx) | 色設定、ツールチップ追加 | 中 |

---

## 8. 実装手順

### Phase 1: データ構造の準備

1. `types/rs-system.ts` に SpendingBlockFlowInfo 型を追加
2. `types/structured.ts` に SpendingBlockFlow 型を追加
3. `types/preset.ts` に subcontract-recipient ノードタイプを追加

### Phase 2: データ生成スクリプトの更新

1. `generate-structured-json.ts` に 5-2 CSV 読み込み処理を追加
2. 間接支出ブロックの除外ロジックを実装（重複カウント防止）
3. SpendingRecord に outflows フィールドを追加
4. `npm run generate-structured` でJSONを再生成
5. 総支出額が 129.63兆円 になることを確認

### Phase 3: サンキー図の更新

1. `sankey-generator.ts` に再委託フロー生成ロジックを追加
2. 支出先ビューで再委託先ノードを表示
3. `app/sankey/page.tsx` で色設定を追加

### Phase 4: テスト

1. プロジェクト7259（電気・ガス価格激変緩和対策等事業）で検証
2. 博報堂 → 東京電力EP、東京ガス、博報堂プロダクツ等への再委託フローが表示されることを確認

---

## 9. 表示例

### 博報堂を選択した場合の表示

```
┌─────────────┐     ┌─────────────┐     ┌─────────────┐     ┌─────────────┐     ┌─────────────────────────┐
│             │     │             │     │             │     │             │     │ 東京電力EP等            │
│  経済産業省  │────▶│  電気・ガス  │────▶│  電気・ガス  │────▶│  博報堂     │────▶│ (間接補助金) 1.90兆円   │
│  2.68兆円   │     │  価格激変   │     │  価格激変   │     │  2.37兆円   │     ├─────────────────────────┤
│             │     │  緩和対策   │     │  緩和対策   │     │             │     │ 東京ガス等              │
└─────────────┘     │  事業       │     │  事業       │     │             │────▶│ (間接補助金) 0.43兆円   │
                    │  (予算)     │     │  (支出)     │     │             │     ├─────────────────────────┤
                    │  2.68兆円   │     │  2.68兆円   │     │             │────▶│ 博報堂プロダクツ等      │
                    │             │     │             │     │             │     │ (委託) 125億円          │
                    └─────────────┘     └─────────────┘     └─────────────┘     └─────────────────────────┘
```

---

## 10. 検証方法

```bash
# データを再生成
npm run generate-structured

# サーバーを起動
npm run dev

# 支出先ビューを確認
# 1. http://localhost:3002/sankey にアクセス
# 2. 経済産業省 → 電気・ガス価格激変緩和対策等事業 をドリルダウン
# 3. 博報堂をクリックして支出先ビューに移動
# 4. 再委託先（東京電力EP、東京ガス等）が表示されることを確認
```

---

## 作成日時

- 作成日: 2026-01-30 19:00
- 担当: Claude Opus 4.5
